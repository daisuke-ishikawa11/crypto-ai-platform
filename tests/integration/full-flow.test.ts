// üß™ ÂÆåÂÖ®„Éï„É≠„ÉºÁµ±Âêà„ÉÜ„Çπ„Éà
// „É¶„Éº„Ç∂„ÉºÁôªÈå≤„Åã„ÇâÂ≠¶Áøí„ÉªÂèñÂºï„ÉªÊ±∫Ê∏à„Åæ„Åß„ÅÆÂÖ®‰Ωì„Éï„É≠„ÉºÊ§úË®º

import { createMocks } from 'node-mocks-http';
import { NextRequest } from 'next/server';
import { createClient } from '@supabase/supabase-js';
import { stripe } from '@/lib/stripe/config';
import { UnifiedAIService } from '@/lib/ai/unified-service';
import { AlertManager } from '@/lib/alerts/alert-manager';

jest.mock('@supabase/supabase-js');
jest.mock('@/lib/stripe/config');
jest.mock('@/lib/ai/unified-service');
jest.mock('@/lib/alerts/alert-manager');

describe('Full User Journey Integration Tests', () => {
  const mockSupabase = {
    auth: {
      signUp: jest.fn(),
      getUser: jest.fn(),
      getSession: jest.fn(),
    },
    from: jest.fn(),
    rpc: jest.fn(),
  };

  const mockStripe = {
    customers: {
      create: jest.fn(),
      list: jest.fn(),
    },
    subscriptions: {
      create: jest.fn(),
    },
    paymentMethods: {
      attach: jest.fn(),
    },
  };

  const mockAIService = {
    performChatAnalysis: jest.fn(),
    generateLearningRecommendations: jest.fn(),
    analyzeMarketConditions: jest.fn(),
  };

  const mockAlertManager = {
    createAlert: jest.fn(),
    processAlerts: jest.fn(),
  };

  beforeEach(() => {
    jest.clearAllMocks();
    (createClient as jest.MockedFunction<typeof createClient>).mockReturnValue(mockSupabase as any);
    jest.mocked(stripe).mockReturnValue(mockStripe as any);
    (UnifiedAIService.getInstance as jest.Mock).mockReturnValue(mockAIService);
    (AlertManager as jest.Mock).mockImplementation(() => mockAlertManager);
  });

  describe('Êñ∞Ë¶è„É¶„Éº„Ç∂„ÉºÂÆåÂÖ®„Éï„É≠„Éº', () => {
    const testUser = {
      id: 'new-user-123',
      email: 'newuser@example.com',
      user_metadata: {
        full_name: 'Êñ∞Ë¶è Â§™ÈÉé'
      }
    };

    it('1. „É¶„Éº„Ç∂„ÉºÁôªÈå≤ ‚Üí „Éó„É≠„Éï„Ç°„Ç§„É´‰ΩúÊàê ‚Üí ÁÑ°Êñô„Éó„É©„É≥ÈñãÂßã', async () => {
      // Step 1: „É¶„Éº„Ç∂„ÉºÁôªÈå≤
      mockSupabase.auth.signUp.mockResolvedValue({
        data: {
          user: testUser,
          session: { access_token: 'test-token' }
        },
        error: null
      });

      // Step 2: StripeÈ°ßÂÆ¢‰ΩúÊàê
      mockStripe.customers.create.mockResolvedValue({
        id: 'cus_new123',
        email: testUser.email
      });

      // Step 3: „É¶„Éº„Ç∂„Éº„Éó„É≠„Éï„Ç°„Ç§„É´‰ΩúÊàê
      mockSupabase.from.mockImplementation((table: string) => {
        if (table === 'user_profiles') {
          return {
            insert: jest.fn().mockResolvedValue({
              data: {
                user_id: testUser.id,
                full_name: testUser.user_metadata.full_name,
                onboarding_completed: false
              },
              error: null
            })
          };
        }
        return mockSupabase.from(table);
      });

      // ÁôªÈå≤API„Ç≥„Éº„É´
      const { POST: signUp } = await import('@/app/api/auth/signup/route');
      const { req } = createMocks({
        method: 'POST',
        headers: {
          'content-type': 'application/json'
        },
        body: {
          email: testUser.email,
          password: 'SecurePassword123!',
          fullName: testUser.user_metadata.full_name
        }
      });

      const response = await signUp(req as NextRequest);
      const data = await response.json();

      expect(response.status).toBe(201);
      expect(data.user.email).toBe(testUser.email);
      expect(mockStripe.customers.create).toHaveBeenCalled();
    });

    it('2. „Ç™„É≥„Éú„Éº„Éá„Ç£„É≥„Ç∞ ‚Üí Â≠¶ÁøíÈñãÂßã ‚Üí ÊúÄÂàù„ÅÆ„É¨„ÉÉ„Çπ„É≥ÂÆå‰∫Ü', async () => {
      mockSupabase.auth.getUser.mockResolvedValue({
        data: { user: testUser },
        error: null
      });

      // „Ç™„É≥„Éú„Éº„Éá„Ç£„É≥„Ç∞ÂÆå‰∫Ü
      mockSupabase.from.mockImplementation((table: string) => {
        if (table === 'user_profiles') {
          return {
            update: jest.fn().mockReturnThis(),
            eq: jest.fn().mockResolvedValue({
              data: { onboarding_completed: true },
              error: null
            })
          };
        }
        if (table === 'user_preferences') {
          return {
            insert: jest.fn().mockResolvedValue({
              data: {
                user_id: testUser.id,
                learning_pace: 'moderate',
                interested_topics: ['financial-literacy', 'trading-basics'],
                risk_tolerance: 'conservative'
              },
              error: null
            })
          };
        }
        return mockSupabase.from(table);
      });

      // AIÊé®Â•®Â≠¶Áøí„Éë„ÇπÁîüÊàê
      mockAIService.generateLearningRecommendations.mockResolvedValue({
        recommendedLessons: [
          { lessonId: 'what-is-cryptocurrency', reason: 'ÊöóÂè∑ÈÄöË≤®„ÅÆÂü∫Á§é„Åã„ÇâÂßã„ÇÅ„Åæ„Åó„Çá„ÅÜ' },
          { lessonId: 'blockchain-basics', reason: '„Éñ„É≠„ÉÉ„ÇØ„ÉÅ„Çß„Éº„É≥ÊäÄË°ì„ÅÆÁêÜËß£„ÅåÈáçË¶Å„Åß„Åô' }
        ],
        learningPath: ['what-is-cryptocurrency', 'blockchain-basics', 'bitcoin-overview']
      });

      // „Ç™„É≥„Éú„Éº„Éá„Ç£„É≥„Ç∞API
      const { POST: completeOnboarding } = await import('@/app/api/onboarding/complete/route');
      const { req: onboardingReq } = createMocks({
        method: 'POST',
        headers: {
          authorization: 'Bearer test-token',
          'content-type': 'application/json'
        },
        body: {
          preferences: {
            learningPace: 'moderate',
            interestedTopics: ['financial-literacy', 'trading-basics'],
            riskTolerance: 'conservative'
          }
        }
      });

      const onboardingResponse = await completeOnboarding(onboardingReq as NextRequest);
      expect(onboardingResponse.status).toBe(200);

      // ÊúÄÂàù„ÅÆ„É¨„ÉÉ„Çπ„É≥ÈñãÂßã
      const { POST: startLesson } = await import('@/app/api/learning/lessons/[slug]/progress/route');
      const { req: lessonReq } = createMocks({
        method: 'POST',
        headers: {
          authorization: 'Bearer test-token',
          'content-type': 'application/json'
        },
        body: {
          action: 'start',
          timeSpent: 0
        }
      });

      const lessonResponse = await startLesson(
        lessonReq as NextRequest,
        { params: { slug: 'what-is-cryptocurrency' } }
      );
      expect(lessonResponse.status).toBe(200);
    });

    it('3. ÊúâÊñô„Éó„É©„É≥„Ç¢„ÉÉ„Éó„Ç∞„É¨„Éº„Éâ ‚Üí È´òÂ∫¶„Å™Ê©üËÉΩËß£Èô§', async () => {
      mockSupabase.auth.getUser.mockResolvedValue({
        data: { user: testUser },
        error: null
      });

      // Stripe„Çµ„Éñ„Çπ„ÇØ„É™„Éó„Ç∑„Éß„É≥‰ΩúÊàê
      mockStripe.subscriptions.create.mockResolvedValue({
        id: 'sub_pro123',
        customer: 'cus_new123',
        status: 'active',
        items: {
          data: [{
            price: {
              id: 'price_pro_monthly',
              unit_amount: 9900
            }
          }]
        },
        current_period_end: Math.floor(Date.now() / 1000) + 30 * 24 * 60 * 60
      });

      // „Éá„Éº„Çø„Éô„Éº„ÇπÊõ¥Êñ∞
      mockSupabase.from.mockImplementation((table: string) => {
        if (table === 'user_subscriptions') {
          return {
            upsert: jest.fn().mockResolvedValue({
              data: {
                user_id: testUser.id,
                stripe_subscription_id: 'sub_pro123',
                status: 'active',
                plan_type: 'pro'
              },
              error: null
            })
          };
        }
        if (table === 'user_features') {
          return {
            update: jest.fn().mockReturnThis(),
            eq: jest.fn().mockResolvedValue({
              data: {
                premium_features_enabled: true,
                ai_analysis_limit: 100,
                alert_limit: 50
              },
              error: null
            })
          };
        }
        return mockSupabase.from(table);
      });

      // „Ç¢„ÉÉ„Éó„Ç∞„É¨„Éº„ÉâAPI
      const { POST: createSubscription } = await import('@/app/api/stripe/subscriptions/route');
      const { req } = createMocks({
        method: 'POST',
        headers: {
          authorization: 'Bearer test-token',
          'content-type': 'application/json'
        },
        body: {
          priceId: 'price_pro_monthly',
          paymentMethodId: 'pm_test123'
        }
      });

      const response = await createSubscription(req as NextRequest);
      const data = await response.json();

      expect(response.status).toBe(201);
      expect(data.subscription.status).toBe('active');
    });

    it('4. „Ç¢„É©„Éº„ÉàË®≠ÂÆö ‚Üí AIÂàÜÊûê ‚Üí ÂèñÂºï„Ç∑„Ç∞„Éä„É´Âèó‰ø°', async () => {
      mockSupabase.auth.getUser.mockResolvedValue({
        data: { user: testUser },
        error: null
      });

      // „Ç¢„É©„Éº„Éà‰ΩúÊàê
      const alertConfig = {
        type: 'smart_composite',
        name: 'BTCÊäïË≥áÊ©ü‰ºö„Ç¢„É©„Éº„Éà',
        conditions: [
          { type: 'price_below', symbol: 'BTC', threshold: 40000 },
          { type: 'rsi_oversold', symbol: 'BTC', threshold: 30 },
          { type: 'ai_signal', symbol: 'BTC', signalType: 'buy_opportunity' }
        ],
        logic: 'AND',
        notification_methods: ['email', 'push', 'in_app']
      };

      mockAlertManager.createAlert.mockResolvedValue({
        id: 'alert-smart-123',
        ...alertConfig,
        user_id: testUser.id,
        status: 'active'
      });

      // AIÂ∏ÇÂ†¥ÂàÜÊûê
      mockAIService.analyzeMarketConditions.mockResolvedValue({
        symbol: 'BTC',
        signal: 'buy_opportunity',
        confidence: 0.85,
        analysis: {
          technical: 'RSI oversold, strong support at $39,500',
          fundamental: 'Positive on-chain metrics, accumulation phase',
          sentiment: 'Fear index showing extreme fear - contrarian buy signal'
        },
        recommendations: [
          'Consider DCA entry between $39,500-$40,500',
          'Set stop loss at $38,000',
          'Target profit zones: $45,000, $48,000'
        ]
      });

      // „Ç¢„É©„Éº„Éà‰ΩúÊàêAPI
      const { POST: createAlert } = await import('@/app/api/alerts/route');
      const { req: alertReq } = createMocks({
        method: 'POST',
        headers: {
          authorization: 'Bearer test-token',
          'content-type': 'application/json'
        },
        body: alertConfig
      });

      const alertResponse = await createAlert(alertReq as NextRequest);
      expect(alertResponse.status).toBe(201);

      // „Ç¢„É©„Éº„ÉàÂá¶ÁêÜÔºà„Éà„É™„Ç¨„ÉºÔºâ
      await mockAlertManager.processAlerts();

      // ÈÄöÁü•Á¢∫Ë™ç
      mockSupabase.from.mockImplementation((table: string) => {
        if (table === 'user_notifications') {
          return {
            select: jest.fn().mockReturnThis(),
            eq: jest.fn().mockReturnThis(),
            order: jest.fn().mockReturnThis(),
            limit: jest.fn().mockResolvedValue({
              data: [{
                id: 'notif-123',
                type: 'alert_triggered',
                title: 'BTCÊäïË≥áÊ©ü‰ºö„Ç¢„É©„Éº„Éà',
                message: 'BTC„ÅåË≤∑„ÅÑ„Ç∑„Ç∞„Éä„É´„ÇíÁô∫Áîü„Åó„Åæ„Åó„Åü',
                data: {
                  alertId: 'alert-smart-123',
                  analysis: mockAIService.analyzeMarketConditions()
                }
              }],
              error: null
            })
          };
        }
        return mockSupabase.from(table);
      });

      // ÈÄöÁü•ÂèñÂæóAPI
      const { GET: getNotifications } = await import('@/app/api/notifications/route');
      const { req: notifReq } = createMocks({
        method: 'GET',
        headers: {
          authorization: 'Bearer test-token'
        }
      });

      const notifResponse = await getNotifications(notifReq as NextRequest);
      const notifData = await notifResponse.json();

      expect(notifResponse.status).toBe(200);
      expect(notifData.notifications).toHaveLength(1);
      expect(notifData.notifications[0].type).toBe('alert_triggered');
    });

    it('5. DeFiÁõ£Ë¶ñ ‚Üí „É™„Çπ„ÇØ„Ç¢„É©„Éº„Éà ‚Üí „Éù„Éº„Éà„Éï„Ç©„É™„Ç™Ë™øÊï¥', async () => {
      mockSupabase.auth.getUser.mockResolvedValue({
        data: { user: testUser },
        error: null
      });

      // DeFi„Éù„Ç∏„Ç∑„Éß„É≥
      const defiPositions = [
        {
          protocol: 'Uniswap',
          pool: 'ETH-USDC',
          value_usd: 10000,
          apy: 15.5,
          impermanent_loss: -2.3
        },
        {
          protocol: 'Aave',
          asset: 'USDC',
          value_usd: 5000,
          apy: 8.2,
          health_factor: 2.5
        }
      ];

      // „É™„Çπ„ÇØ„Ç¢„É©„Éº„Éà
      const riskAlert = {
        type: 'defi_risk',
        severity: 'medium',
        protocol: 'Aave',
        message: 'Health factor„Åå2.5„Å´‰Ωé‰∏ã„Åó„Åæ„Åó„Åü',
        recommendations: [
          'ËøΩÂä†ÊãÖ‰øù„ÅÆÈ†êÂÖ•„ÇíÊ§úË®é„Åó„Å¶„Åè„Å†„Åï„ÅÑ',
          'ÂÄüÂÖ•È°ç„ÅÆ‰∏ÄÈÉ®ËøîÊ∏à„ÇíÊé®Â•®„Åó„Åæ„Åô'
        ]
      };

      mockSupabase.from.mockImplementation((table: string) => {
        if (table === 'user_defi_positions') {
          return {
            select: jest.fn().mockReturnThis(),
            eq: jest.fn().mockResolvedValue({
              data: defiPositions,
              error: null
            })
          };
        }
        if (table === 'defi_risk_alerts') {
          return {
            insert: jest.fn().mockResolvedValue({
              data: riskAlert,
              error: null
            })
          };
        }
        return mockSupabase.from(table);
      });

      // DeFiÁõ£Ë¶ñAPI
      const { GET: getDefiStatus } = await import('@/app/api/defi/status/route');
      const { req } = createMocks({
        method: 'GET',
        headers: {
          authorization: 'Bearer test-token'
        }
      });

      const response = await getDefiStatus(req as NextRequest);
      const data = await response.json();

      expect(response.status).toBe(200);
      expect(data.positions).toHaveLength(2);
      expect(data.totalValue).toBe(15000);
      expect(data.riskAlerts).toHaveLength(1);
    });
  });

  describe('„Ç®„É©„Éº„É™„Ç´„Éê„É™„Éº„Å®„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ', () => {
    it('ÈÉ®ÂàÜÁöÑ„Å™„Çµ„Éº„Éì„ÇπÈöúÂÆ≥ÊôÇ„ÅÆÂÑ™ÈõÖ„Å™Âä£Âåñ', async () => {
      const testUser = {
        id: 'user-456',
        email: 'test@example.com'
      };

      mockSupabase.auth.getUser.mockResolvedValue({
        data: { user: testUser },
        error: null
      });

      // Stripe„Çµ„Éº„Éì„ÇπÂÅúÊ≠¢„Çí„Ç∑„Éü„É•„É¨„Éº„Éà
      mockStripe.customers.list.mockRejectedValue(new Error('Service unavailable'));

      // AI „Çµ„Éº„Éì„ÇπÈÉ®ÂàÜÈöúÂÆ≥
      mockAIService.analyzeMarketConditions.mockRejectedValue(new Error('AI service error'));
      mockAIService.generateLearningRecommendations.mockResolvedValue({
        recommendedLessons: [], // „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÔºöÁ©∫„ÅÆÊé®Â•®
        learningPath: []
      });

      // „ÉÄ„ÉÉ„Ç∑„É•„Éú„Éº„ÉâAPIÔºà„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÂá¶ÁêÜÔºâ
      const { GET: getDashboard } = await import('@/app/api/dashboard/route');
      const { req } = createMocks({
        method: 'GET',
        headers: {
          authorization: 'Bearer test-token'
        }
      });

      const response = await getDashboard(req as NextRequest);
      const data = await response.json();

      // ÈÉ®ÂàÜÁöÑ„Å™„Ç®„É©„Éº„Åß„ÇÇ200„ÇíËøî„Åó„ÄÅÂà©Áî®ÂèØËÉΩ„Å™„Éá„Éº„Çø„ÇíÊèê‰æõ
      expect(response.status).toBe(200);
      expect(data).toHaveProperty('portfolio');
      expect(data).toHaveProperty('learning');
      expect(data.subscription).toBeNull(); // Stripe„Ç®„É©„Éº„ÅÆ„Åü„ÇÅnull
      expect(data.marketAnalysis).toBeNull(); // AI„Ç®„É©„Éº„ÅÆ„Åü„ÇÅnull
    });

    it('ÂêåÊôÇÂ§ßÈáè„É™„ÇØ„Ç®„Çπ„Éà„ÅÆÂá¶ÁêÜ', async () => {
      const testUser = {
        id: 'user-789',
        email: 'load@example.com'
      };

      mockSupabase.auth.getUser.mockResolvedValue({
        data: { user: testUser },
        error: null
      });

      // 100ÂÄã„ÅÆÂêåÊôÇ„É™„ÇØ„Ç®„Çπ„Éà„Çí„Ç∑„Éü„É•„É¨„Éº„Éà
      const { GET } = await import('@/app/api/market/prices/route');
      const requests = Array.from({ length: 100 }, (_, i) => {
        const { req } = createMocks({
          method: 'GET',
          headers: {
            authorization: 'Bearer test-token'
          },
          query: {
            symbols: 'BTC,ETH',
            requestId: `req-${i}`
          }
        });

        return GET(req as NextRequest);
      });

      const startTime = Date.now();
      const responses = await Promise.all(requests);
      const endTime = Date.now();
      const totalTime = endTime - startTime;

      // „Åô„Åπ„Å¶„ÅÆ„É™„ÇØ„Ç®„Çπ„Éà„ÅåÊàêÂäü
      responses.forEach(response => {
        expect(response.status).toBe(200);
      });

      // ‰∏¶ÂàóÂá¶ÁêÜ„Å´„Çà„ÇäÂ¶•ÂΩì„Å™ÊôÇÈñìÂÜÖ„Å´ÂÆå‰∫Ü
      expect(totalTime).toBeLessThan(5000); // 5Áßí‰ª•ÂÜÖ
    });
  });

  describe('„Çª„Ç≠„É•„É™„ÉÜ„Ç£„Å®„Ç≥„É≥„Éó„É©„Ç§„Ç¢„É≥„Çπ', () => {
    it('‰∏çÊ≠£„Å™„Ç¢„ÇØ„Çª„ÇπË©¶Ë°å„ÅÆÊ§úÂá∫„Å®„Éñ„É≠„ÉÉ„ÇØ', async () => {
      // ÁÑ°Âäπ„Å™„Éà„Éº„ÇØ„É≥
      const { GET } = await import('@/app/api/dashboard/route');
      const { req: invalidReq } = createMocks({
        method: 'GET',
        headers: {
          authorization: 'Bearer invalid-token'
        }
      });

      const invalidResponse = await GET(invalidReq as NextRequest);
      expect(invalidResponse.status).toBe(401);

      // SQL„Ç§„É≥„Ç∏„Çß„ÇØ„Ç∑„Éß„É≥Ë©¶Ë°å
      const { POST } = await import('@/app/api/alerts/route');
      const { req: sqlReq } = createMocks({
        method: 'POST',
        headers: {
          authorization: 'Bearer test-token',
          'content-type': 'application/json'
        },
        body: {
          type: "'; DROP TABLE users; --",
          symbol: 'BTC',
          threshold: 50000
        }
      });

      const sqlResponse = await POST(sqlReq as NextRequest);
      expect(sqlResponse.status).toBe(400); // „Éê„É™„Éá„Éº„Ç∑„Éß„É≥„Ç®„É©„Éº

      // „É¨„Éº„ÉàÂà∂Èôê„ÉÅ„Çß„ÉÉ„ÇØ
      const rateLimitRequests = Array.from({ length: 150 }, () => {
        const { req } = createMocks({
          method: 'GET',
          headers: {
            authorization: 'Bearer test-token'
          }
        });
        return GET(req as NextRequest);
      });

      // ÊúÄÂàù„ÅÆ100„É™„ÇØ„Ç®„Çπ„Éà„ÅØÊàêÂäü„ÄÅ„Åù„ÅÆÂæå„ÅØ„É¨„Éº„ÉàÂà∂Èôê
      const rateLimitResponses = await Promise.all(rateLimitRequests);
      const successCount = rateLimitResponses.filter(r => r.status === 200).length;
      const rateLimitedCount = rateLimitResponses.filter(r => r.status === 429).length;

      expect(successCount).toBeLessThanOrEqual(100);
      expect(rateLimitedCount).toBeGreaterThan(0);
    });
  });
});